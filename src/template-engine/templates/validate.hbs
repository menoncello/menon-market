#!/usr/bin/env bun

/**
 * {{description}}
 * Generated on: {{currentDate}}
 * Validation Rules: {{VALIDATION_RULES}}
 */

import { readdir, readFile } from "node:fs/promises";
import { join } from "node:path";

interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export class {{bun-class className}}Validator {
  private pluginPath: string;
  private strictMode: {{STRICT_MODE}};

  constructor(pluginPath: string, options = {}) {
    this.pluginPath = pluginPath;
    this.strictMode = options.strictMode ?? true;
  }

  async validate(): Promise<ValidationResult> {
    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: []
    };

    // Validate plugin.json
    await this.validatePluginJson(result);

    {{#if AUTO_FIX}}
    // Auto-fix common issues
    await this.autoFix(result);
    {{/if}}

    result.valid = result.errors.length === 0;
    return result;
  }

  private async validatePluginJson(result: ValidationResult): Promise<void> {
    const configPath = join(this.pluginPath, ".claude-plugin", "plugin.json");

    try {
      const content = await readFile(configPath, 'utf-8');
      const config = JSON.parse(content);

      // Required fields validation
      const required = ['name', 'version', 'description'];
      for (const field of required) {
        if (!config[field]) {
          result.errors.push(`Missing required field: ${field}`);
        }
      }

    } catch (error) {
      result.errors.push(`Failed to read plugin.json: ${error.message}`);
    }
  }
}

// CLI interface
if (import.meta.main) {
  const validator = new {{bun-class className}}Validator(process.argv[2] || '.');

  validator.validate()
    .then(result => {
      if (result.valid) {
        console.log("✅ Plugin validation passed");
      } else {
        console.log("❌ Plugin validation failed:");
        result.errors.forEach(error => console.log(`  - ${error}`));
      }
    })
    .catch(console.error);
}