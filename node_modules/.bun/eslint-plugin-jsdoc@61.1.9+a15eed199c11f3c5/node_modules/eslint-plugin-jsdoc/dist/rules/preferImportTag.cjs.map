{"version":3,"file":"preferImportTag.cjs","names":["_iterateJsdoc","_interopRequireWildcard","require","_jsdoccomment","_parseImportsExports","_toValidIdentifier","_interopRequireDefault","e","__esModule","default","t","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_default","exports","iterateJsdoc","context","indent","jsdoc","settings","sourceCode","utils","mode","enableFixer","exemptTypedefs","outputType","options","allComments","getAllComments","comments","filter","comment","test","value","map","commentNode","commentParserToESTree","parseComment","typedefs","flatMap","doc","tags","tag","isNameOrNamepathDefiningTag","imports","delimiter","iterateInlineImports","potentialType","type","parsedType","tryParseType","parseType","traverse","nde","parentNode","element","currentNode","pathSegments","nodes","extraPathSegments","quotes","propertyOrBrackets","unshift","right","stringify","pathType","undefined","meta","quote","getFixer","name","extrPathSegments","matchingName","toValidIdentifier","node","at","keys","key","length","newNode","shift","left","nameNode","src","source","tokens","unusedPathSegments","findMatchingTypedef","pthSegments","find","typedef","typedefNode","namepathMatch","pathSegment","push","matchingTypedef","reportJSDoc","slice","findMatchingImport","imprt","parsedImport","parseImportsExports","estreeToString","replace","trim","namedImportsModuleSpecifier","namedImports","values","namedImportNames","names","namespaceImports","namespaceImportsDefault","namespaceImportsNamespace","namespace","namespaceImportsModuleSpecifier","lastPathSegment","includes","matchingImport","lastPthSegment","fixer","programNode","ast","commentNodes","getCommentsBefore","insertTextBefore","lstPathSegment","mightHaveTypePosition","tagMightHaveTypePosition","hasTypePosition","Boolean","iterateAllJsdocs","docs","description","url","fixable","schema","additionalProperties","properties","enum","module"],"sources":["../../src/rules/preferImportTag.js"],"sourcesContent":["import iterateJsdoc, {\n  parseComment,\n} from '../iterateJsdoc.js';\nimport {\n  commentParserToESTree,\n  estreeToString,\n  // getJSDocComment,\n  parse as parseType,\n  stringify,\n  traverse,\n  tryParse as tryParseType,\n} from '@es-joy/jsdoccomment';\nimport {\n  parseImportsExports,\n} from 'parse-imports-exports';\nimport toValidIdentifier from 'to-valid-identifier';\n\nexport default iterateJsdoc(({\n  context,\n  indent,\n  jsdoc,\n  settings,\n  sourceCode,\n  utils,\n}) => {\n  const {\n    mode,\n  } = settings;\n\n  const {\n    enableFixer = true,\n    exemptTypedefs = true,\n    outputType = 'namespaced-import',\n  } = context.options[0] || {};\n\n  const allComments = sourceCode.getAllComments();\n  const comments = allComments\n    .filter((comment) => {\n      return (/^\\*(?!\\*)/v).test(comment.value);\n    })\n    .map((commentNode) => {\n      return commentParserToESTree(\n        parseComment(commentNode, ''), mode === 'permissive' ? 'typescript' : mode,\n      );\n    });\n\n  const typedefs = comments\n    .flatMap((doc) => {\n      return doc.tags.filter(({\n        tag,\n      }) => {\n        return utils.isNameOrNamepathDefiningTag(tag);\n      });\n    });\n\n  const imports = comments\n    .flatMap((doc) => {\n      return doc.tags.filter(({\n        tag,\n      }) => {\n        return tag === 'import';\n      });\n    }).map((tag) => {\n      // Causes problems with stringification otherwise\n      tag.delimiter = '';\n      return tag;\n    });\n\n  /**\n   * @param {import('@es-joy/jsdoccomment').JsdocTagWithInline} tag\n   */\n  const iterateInlineImports = (tag) => {\n    const potentialType = tag.type;\n    let parsedType;\n    try {\n      parsedType = mode === 'permissive' ?\n        tryParseType(/** @type {string} */ (potentialType)) :\n        parseType(/** @type {string} */ (potentialType), mode);\n    } catch {\n      return;\n    }\n\n    traverse(parsedType, (nde, parentNode) => {\n      // @ts-expect-error Adding our own property for use below\n      nde.parentNode = parentNode;\n    });\n\n    traverse(parsedType, (nde) => {\n      const {\n        element,\n        type,\n      } = /** @type {import('jsdoc-type-pratt-parser').ImportResult} */ (nde);\n      if (type !== 'JsdocTypeImport') {\n        return;\n      }\n\n      let currentNode = nde;\n\n      /** @type {string[]} */\n      const pathSegments = [];\n\n      /** @type {import('jsdoc-type-pratt-parser').NamePathResult[]} */\n      const nodes = [];\n\n      /** @type {string[]} */\n      const extraPathSegments = [];\n\n      /** @type {(import('jsdoc-type-pratt-parser').QuoteStyle|undefined)[]} */\n      const quotes = [];\n\n      const propertyOrBrackets = /** @type {import('jsdoc-type-pratt-parser').NamePathResult['pathType'][]} */ ([]);\n\n      // @ts-expect-error Referencing our own property added above\n      while (currentNode && currentNode.parentNode) {\n        // @ts-expect-error Referencing our own property added above\n        currentNode = currentNode.parentNode;\n        /* c8 ignore next 3 -- Guard */\n        if (currentNode.type !== 'JsdocTypeNamePath') {\n          break;\n        }\n\n        pathSegments.unshift(\n          currentNode.right.type === 'JsdocTypeIndexedAccessIndex' ?\n            stringify(currentNode.right.right) :\n            currentNode.right.value,\n        );\n        nodes.unshift(currentNode);\n        propertyOrBrackets.unshift(currentNode.pathType);\n        quotes.unshift(\n          currentNode.right.type === 'JsdocTypeIndexedAccessIndex' ?\n            undefined :\n            currentNode.right.meta.quote,\n        );\n      }\n\n      /**\n       * @param {string} name\n       * @param {string[]} extrPathSegments\n       */\n      const getFixer = (name, extrPathSegments) => {\n        const matchingName = toValidIdentifier(name);\n        return () => {\n          /** @type {import('jsdoc-type-pratt-parser').NamePathResult|undefined} */\n          let node = nodes.at(0);\n          if (!node) {\n            // Not really a NamePathResult, but will be converted later anyways\n            node = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n              /** @type {unknown} */\n              (nde)\n            );\n          }\n\n          const keys = /** @type {(keyof import('jsdoc-type-pratt-parser').NamePathResult)[]} */ (\n            Object.keys(node)\n          );\n\n          for (const key of keys) {\n            delete node[key];\n          }\n\n          if (extrPathSegments.length) {\n            let newNode = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n              /** @type {unknown} */\n              (node)\n            );\n            while (extrPathSegments.length && newNode) {\n              newNode.type = 'JsdocTypeNamePath';\n              newNode.right = {\n                meta: {\n                  quote: quotes.shift(),\n                },\n                type: 'JsdocTypeProperty',\n                value: /** @type {string} */ (extrPathSegments.shift()),\n              };\n\n              newNode.pathType = /** @type {import('jsdoc-type-pratt-parser').NamePathResult['pathType']} */ (\n                propertyOrBrackets.shift()\n              );\n              // @ts-expect-error Temporary\n              newNode.left = {};\n              newNode = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n                newNode.left\n              );\n            }\n\n            const nameNode = /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n              /** @type {unknown} */\n              (newNode)\n            );\n            nameNode.type = 'JsdocTypeName';\n            nameNode.value = matchingName;\n          } else {\n            const newNode = /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n              /** @type {unknown} */\n              (node)\n            );\n            newNode.type = 'JsdocTypeName';\n            newNode.value = matchingName;\n          }\n\n          for (const src of tag.source) {\n            if (src.tokens.type) {\n              src.tokens.type = `{${stringify(parsedType)}}`;\n              break;\n            }\n          }\n        };\n      };\n\n      /** @type {string[]} */\n      let unusedPathSegments = [];\n\n      const findMatchingTypedef = () => {\n        // Don't want typedefs to find themselves\n        if (!exemptTypedefs) {\n          return undefined;\n        }\n\n        const pthSegments = [\n          ...pathSegments,\n        ];\n        return typedefs.find((typedef) => {\n          let typedefNode = typedef.parsedType;\n          let namepathMatch;\n          while (typedefNode && typedefNode.type === 'JsdocTypeNamePath') {\n            const pathSegment = pthSegments.shift();\n            if (!pathSegment) {\n              namepathMatch = false;\n              break;\n            }\n\n            if (\n              (typedefNode.right.type === 'JsdocTypeIndexedAccessIndex' &&\n                stringify(typedefNode.right.right) !== pathSegment) ||\n              (typedefNode.right.type !== 'JsdocTypeIndexedAccessIndex' &&\n                typedefNode.right.value !== pathSegment)\n            ) {\n              if (namepathMatch === true) {\n                // It stopped matching, so stop\n                break;\n              }\n\n              extraPathSegments.push(pathSegment);\n              namepathMatch = false;\n              continue;\n            }\n\n            namepathMatch = true;\n\n            unusedPathSegments = pthSegments;\n\n            typedefNode = typedefNode.left;\n          }\n\n          return namepathMatch &&\n            // `import('eslint')` matches\n            typedefNode &&\n            typedefNode.type === 'JsdocTypeImport' &&\n            typedefNode.element.value === element.value;\n        });\n      };\n\n      // Check @typedef's first as should be longest match, allowing\n      //   for shorter abbreviations\n      const matchingTypedef = findMatchingTypedef();\n      if (matchingTypedef) {\n        utils.reportJSDoc(\n          'Inline `import()` found; using `@typedef`',\n          tag,\n          enableFixer ? getFixer(matchingTypedef.name, [\n            ...extraPathSegments,\n            ...unusedPathSegments.slice(-1),\n            ...unusedPathSegments.slice(0, -1),\n          ]) : null,\n        );\n        return;\n      }\n\n      const findMatchingImport = () => {\n        for (const imprt of imports) {\n          const parsedImport = parseImportsExports(\n            estreeToString(imprt).replace(/^\\s*@/v, '').trim(),\n          );\n\n          const namedImportsModuleSpecifier = Object.keys(parsedImport.namedImports || {})[0];\n\n          const namedImports = Object.values(parsedImport.namedImports || {})[0]?.[0];\n          const namedImportNames = (namedImports && namedImports.names && Object.keys(namedImports.names)) ?? [];\n\n          const namespaceImports = Object.values(parsedImport.namespaceImports || {})[0]?.[0];\n\n          const namespaceImportsDefault = namespaceImports && namespaceImports.default;\n          const namespaceImportsNamespace = namespaceImports && namespaceImports.namespace;\n          const namespaceImportsModuleSpecifier = Object.keys(parsedImport.namespaceImports || {})[0];\n\n          const lastPathSegment = pathSegments.at(-1);\n\n          if (\n            (namespaceImportsDefault &&\n                namespaceImportsModuleSpecifier === element.value) ||\n              (element.value === namedImportsModuleSpecifier && (\n                (lastPathSegment && namedImportNames.includes(lastPathSegment)) ||\n                lastPathSegment === 'default'\n              )) ||\n              (namespaceImportsNamespace &&\n                namespaceImportsModuleSpecifier === element.value)\n          ) {\n            return {\n              namedImportNames,\n              namedImports,\n              namedImportsModuleSpecifier,\n              namespaceImports,\n              namespaceImportsDefault,\n              namespaceImportsModuleSpecifier,\n              namespaceImportsNamespace,\n            };\n          }\n        }\n\n        return undefined;\n      };\n\n      const matchingImport = findMatchingImport();\n      if (matchingImport) {\n        const {\n          namedImportNames,\n          namedImports,\n          namedImportsModuleSpecifier,\n          namespaceImportsNamespace,\n        } = matchingImport;\n        if (!namedImportNames.length && namedImportsModuleSpecifier && namedImports.default) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(namedImports.default, []) : null,\n          );\n          return;\n        }\n\n        const lastPthSegment = pathSegments.at(-1);\n        if (lastPthSegment && namedImportNames.includes(lastPthSegment)) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(lastPthSegment, pathSegments.slice(0, -1)) : null,\n          );\n          return;\n        }\n\n        if (namespaceImportsNamespace) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(namespaceImportsNamespace, [\n              ...pathSegments,\n            ]) : null,\n          );\n          return;\n        }\n      }\n\n      if (!pathSegments.length) {\n        utils.reportJSDoc(\n          'Inline `import()` found; prefer `@import`',\n          tag,\n          enableFixer ? (fixer) => {\n            getFixer(element.value, [])();\n\n            const programNode = sourceCode.ast;\n            const commentNodes = sourceCode.getCommentsBefore(programNode);\n            return fixer.insertTextBefore(\n              // @ts-expect-error Ok\n              commentNodes[0] ?? programNode,\n              `/** @import * as ${toValidIdentifier(element.value)} from '${element.value}'; */${\n                commentNodes[0] ? '\\n' + indent : ''\n              }`,\n            );\n          } : null,\n        );\n        return;\n      }\n\n      const lstPathSegment = pathSegments.at(-1);\n      if (lstPathSegment && lstPathSegment === 'default') {\n        utils.reportJSDoc(\n          'Inline `import()` found; prefer `@import`',\n          tag,\n          enableFixer ? (fixer) => {\n            getFixer(element.value, [])();\n\n            const programNode = sourceCode.ast;\n            const commentNodes = sourceCode.getCommentsBefore(programNode);\n\n            return fixer.insertTextBefore(\n              // @ts-expect-error Ok\n              commentNodes[0] ?? programNode,\n              `/** @import ${element.value} from '${element.value}'; */${\n                commentNodes[0] ? '\\n' + indent : ''\n              }`,\n            );\n          } : null,\n        );\n        return;\n      }\n\n      utils.reportJSDoc(\n        'Inline `import()` found; prefer `@import`',\n        tag,\n        enableFixer ? (fixer) => {\n          if (outputType === 'namespaced-import') {\n            getFixer(element.value, [\n              ...pathSegments,\n            ])();\n          } else {\n            getFixer(\n              /** @type {string} */ (pathSegments.at(-1)),\n              pathSegments.slice(0, -1),\n            )();\n          }\n\n          const programNode = sourceCode.ast;\n          const commentNodes = sourceCode.getCommentsBefore(programNode);\n          return fixer.insertTextBefore(\n            // @ts-expect-error Ok\n            commentNodes[0] ?? programNode,\n            outputType === 'namespaced-import' ?\n              `/** @import * as ${toValidIdentifier(element.value)} from '${element.value}'; */${\n                commentNodes[0] ? '\\n' + indent : ''\n              }` :\n              `/** @import { ${toValidIdentifier(\n                /* c8 ignore next -- TS */\n                pathSegments.at(-1) ?? '',\n              )} } from '${element.value}'; */${\n                commentNodes[0] ? '\\n' + indent : ''\n              }`,\n          );\n        } : null,\n      );\n    });\n  };\n\n  for (const tag of jsdoc.tags) {\n    const mightHaveTypePosition = utils.tagMightHaveTypePosition(tag.tag);\n    const hasTypePosition = mightHaveTypePosition === true && Boolean(tag.type);\n    if (hasTypePosition && (!exemptTypedefs || !utils.isNameOrNamepathDefiningTag(tag.tag))) {\n      iterateInlineImports(tag);\n    }\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Prefer `@import` tags to inline `import()` statements.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/prefer-import-tag.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          enableFixer: {\n            description: 'Whether or not to enable the fixer to add `@import` tags.',\n            type: 'boolean',\n          },\n          exemptTypedefs: {\n            description: 'Whether to allow `import()` statements within `@typedef`',\n            type: 'boolean',\n          },\n\n          // We might add `typedef` and `typedef-local-only`, but also raises\n          //   question of how deep the generated typedef should be\n          outputType: {\n            description: 'What kind of `@import` to generate when no matching `@typedef` or `@import` is found',\n            enum: [\n              'named-import',\n              'namespaced-import',\n            ],\n            type: 'string',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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","ignoreList":[]}